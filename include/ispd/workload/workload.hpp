#ifndef ISPD_WORKLOAD_HPP
#define ISPD_WORKLOAD_HPP

#include <ross.h>
#include <memory>
#include <ispd/model/user.hpp>
#include <ispd/workload/interarrival.hpp>
#define VM_FLAG 0
#define TASK_FLAG 1
#define CHECK_RNG(rng) DEBUG({ if (!rng) ispd_error("The logical process' reversible-pseudorandom number generator has not been provided."); })

namespace ispd::workload {

/// \class Workload
///
/// \brief A base class representing a workload to be generated for a
/// simulation.
///
class Workload {
protected:
  /// \brief Stores the user who created the workload.
  ///
  /// This member variable holds an integer representing the identifier of the
  /// user-defined workload associated with the current instance of the Workload class.
  ///
  /// The user identifier who created the workload can provide context and information about the
  /// specific type of workload being simulated, making it easier to interpret and analyze
  /// simulation results or performance metrics.
  ispd::model::User::uid_t m_Owner;

  /// \brief The remaining tasks to be generated by this workload.
  ///
  /// The `m_RemainingTasks` member stores the count of tasks that are yet to be
  /// generated by the workload. It is decremented as tasks are generated during
  /// the simulation. This information allows simulation components to keep
  /// track of the workload progress and workload generation termination
  /// conditions.
  unsigned m_RemainingTasks;

  unsigned m_RemainingVms;


  /// \brief Unique pointer to InterarrivalDistribution.
  ///
  /// This member variable holds a `std::unique_ptr` to an `InterarrivalDistribution`
  /// object associated with the current instance of the Workload class. The
  /// `InterarrivalDistribution` is responsible for generating time intervals
  /// between the arrivals of consecutive events within the workload.
  ///
  /// Using a `std::unique_ptr` ensures proper memory management and ownership of
  /// the dynamically allocated `InterarrivalDistribution` object. This allows
  /// flexible and efficient handling of different interarrival distribution types
  /// and ensures that the object is properly deallocated when the Workload is no
  /// longer in use.
  std::unique_ptr<InterarrivalDistribution> m_InterarrivalDist;
  
public:
  /// \brief Constructor for the Workload class.
  ///
  /// Creates a new `Workload` object with the specified user, remaining tasks,
  /// and an associated interarrival distribution.
  ///
  /// \param owner The user who created the workload.
  /// \param remainingTasks The total number of tasks that need to be generated
  ///                       by the workload.
  /// \param interarrivalDist A unique pointer to an InterarrivalDistribution
  ///                        object that represents the distribution of time
  ///                        between consecutive task arrivals.
  explicit Workload(const std::string& owner, const unsigned remainingTasks,
    const std::unique_ptr<InterarrivalDistribution> interarrivalDist);


  /// Workload for cloud using override
  explicit Workload(const std::string& owner, const unsigned remainingTasks, const unsigned remainingVms,
                    const std::unique_ptr<InterarrivalDistribution> interarrivalDist);

  /// \brief Generate the workload, setting the processing and communication
  ///        sizes depending on the generation policy.
  ///
  /// This pure virtual function defines the interface for workload generation
  /// in derived classes. Each derived workload class must implement this
  /// function to generate the workload's processing and communication sizes
  /// based on the specific generation policy. The actual logic for generating
  /// workload characteristics can vary between different workload types.
  ///
  /// \param rng The logical process reversible-pseudonumber random generator.
  /// \param procSize A reference to the processing size to be updated based on
  ///                 the generated workload.
  /// \param commSize A reference to the communication size to be updated based
  ///                 on the generated workload.
  virtual void generateWorkload(tw_rng_stream *rng, double &procSize,
                                double &commSize, unsigned flag) = 0;

  /// \brief Reverse the workload generation, necessary due to the Time Warp's
  ///        rollback mechanism.
  ///
  /// This pure virtual function defines the interface for reversing the
  /// workload generation in derived classes. Time Warp is a distributed
  /// discrete-event simulation technique that allows for virtual time rollback
  /// to correct causality errors. To support rollback, this function enables
  /// the workload generation to be reversed, so the simulation can roll back
  /// the workload's state if necessary.
  ///
  /// \param rng The logical process reversible-pseudorandom number generator.
  virtual void reverseGenerateWorkload(tw_rng_stream *rng, unsigned flag) = 0;

  /// \brief Generates the time until the next event's arrival using the interarrival distribution.
  ///
  /// This function generates the time until the next event's arrival based on the
  /// specified interarrival distribution. The generated time offset is stored in the
  /// provided 'offset' parameter. The interarrival distribution is determined by the type
  /// of interarrival distribution object associated with the current instance of the Workload class.
  ///
  /// \param rng A pointer to the logical process reversible-pseudorandom number generator.
  /// \param offset A reference to a variable where the generated time offset will be stored.
  inline void generateInterarrival(tw_rng_stream *const rng, double &offset) {
    m_InterarrivalDist->generateInterarrival(rng, offset);
  }

  /// \brief Reverses the generation of the last interarrival time, necessary due to the
  ///        Time Warp's rollback mechanism.
  ///
  /// This function is used to reverse the generation of the last interarrival time when
  /// performing backtracking during the simulation. It relies on the reverse generation
  /// mechanism provided by the associated interarrival distribution object.
  ///
  /// \param rng A pointer to the logical process reversible-pseudorandom number generator.
  inline void reverseGenerateInterarrival(tw_rng_stream *const rng) {
    m_InterarrivalDist->reverseGenerateInterarrival(rng);
  }

  /// \brief Get the remaining tasks to be generated by this workload.
  ///
  /// \returns The number of tasks that are yet to be generated by the workload.
  ///
  /// \note This function provides access to the `m_RemainingTasks` member,
  ///       which stores the count of remaining tasks. It is used by simulation
  ///       components to monitor the progress of workload generation and
  ///       determine workload generation termination conditions.
  inline unsigned getRemainingTasks() { return m_RemainingTasks; }

  inline unsigned getRemainingVms() {return m_RemainingVms;}

  /// \brief Get the user identifier who create the workload.
  ///
  /// This member function returns the user identifier who created the workload
  /// associated with the current instance of the Workload class.
  ///
  /// \return The user identifier who created the workload.
  inline const ispd::model::User::uid_t getOwner() { return m_Owner; }
};

/// \class ConstantWorkload
///
/// \brief A derived class representing a constant workload for simulation
///        tasks, all generated tasks will have the same workload.
///
class ConstantWorkload : public Workload {
  /// \brief The constant processing size to be set for all generated tasks.
  ///
  /// The `m_ConstantProcSize` member stores the constant processing size that
  /// will be assigned to all tasks generated by this workload. This value
  /// remains constant throughout the simulation for all tasks generated using
  /// this workload.
  double m_ConstantProcSize;

  /// \brief The constant communication size to be set for all generated tasks.
  ///
  /// The `m_ConstantCommSize` member stores the constant communication size
  /// that will be assigned to all tasks generated by this workload. This value
  /// remains constant throughout the simulation for all tasks generated using
  /// this workload.
  double m_ConstantCommSize;

public:
  /// \brief ConstantWorkload class constructor.
  ///
  /// Creates a new `ConstantWorkload` object with the specified parameters.
  ///
  /// \param owner The user who created the workload.
  /// \param remainingTasks The total tasks to be generated by the workload.
  /// \param constantProcSize Constant processing size for all generated tasks.
  /// \param constantCommSize Constant communication size for all generated tasks.
  /// \param interarrivalDist Unique pointer to associated interarrival distribution.
  ///
 explicit ConstantWorkload(const std::string& owner,
                            const unsigned remainingTasks,
                            const double constantProcSize,
                            const double constantCommSize,
                            std::unique_ptr<InterarrivalDistribution> interarrivalDist);

 explicit ConstantWorkload(const std::string& owner,
                           const unsigned remainingTasks,
                           const unsigned remainingVms,
                           const double constantProcSize,
                           const double constantCommSize,
                           std::unique_ptr<InterarrivalDistribution> interarrivalDist);

  /// \brief Generate the constant workload, setting the processing and
  /// communication sizes.
  ///
  /// This member function implements the workload generation logic for the
  /// `ConstantWorkload` class. It sets the processing size (`procSize`) and
  /// communication size (`commSize`) to the constant values specified during
  /// object construction. The remaining tasks counter in the base class
  /// (`Workload::m_RemainingTasks`) is decremented after generating the
  /// workload for a task.
  ///
  /// \param rng The logical process reversible-pseudorandom number generator.
  /// \param procSize A reference to the processing size to be updated based on
  ///                 the constant workload generation.
  /// \param commSize A reference to the communication size to be updated based
  ///                 on the constant workload generation.
  void generateWorkload(tw_rng_stream *rng, double &procSize,
                        double &commSize, unsigned flag) override {
    CHECK_RNG(rng);

    procSize = m_ConstantProcSize;
    commSize = m_ConstantCommSize;

    if(flag == VM_FLAG)
      Workload::m_RemainingVms--;
    else
      Workload::m_RemainingTasks--;


      }

  /// \brief Reverse the constant workload generation, needed due to Time Warp's
  /// rollback mechanism.
  ///
  /// This member function reverses the workload generation for the
  /// `ConstantWorkload` class to support Time Warp's rollback mechanism. When a
  /// rollback occurs, the remaining tasks counter in the base class
  /// (`Workload::m_RemainingTasks`) is incremented to revert the effects of
  /// generating workload for a task.
  ///
  /// \param rng The logical process reversible-pseudorandom number generator.
  void reverseGenerateWorkload(tw_rng_stream *rng, unsigned flag) override {
    CHECK_RNG(rng);
    if(flag == VM_FLAG)
      Workload::m_RemainingVms++;
    else
      Workload::m_RemainingTasks++;

  }
};

/// \class UniformWorkload
///
/// \brief A derived class representing a uniform workload for simulation tasks.
///
class UniformWorkload : public Workload {
  /// \brief The minimum processing size for generated tasks.
  double m_MinProcSize;

  /// \brief The maximum processing size for generated tasks.
  double m_MaxProcSize;

  /// \brief The minimum communication size for generated tasks.
  double m_MinCommSize;

  /// \brief The maximum communication size for generated tasks.
  double m_MaxCommSize;

public:
  /// \brief UniformWorkload class constructor.
  ///
  /// Creates a new `UniformWorkload` object with the specified parameters.
  ///
  /// \param owner The user who created the workload.
  /// \param remainingTasks Total tasks to be generated by the workload.
  /// \param minProcSize Minimum processing size for generated tasks.
  /// \param maxProcSize Maximum processing size for generated tasks.
  /// \param minCommSize Minimum communication size for generated tasks.
  /// \param maxCommSize Maximum communication size for generated tasks.
  /// \param interarrivalDist Unique pointer to associated interarrival distribution.
  ///
 explicit UniformWorkload(const std::string& owner,
                          const unsigned remainingTasks,
                          const double minProcSize, const double maxProcSize,
                          const double minCommSize, const double maxCommSize,
                          std::unique_ptr<InterarrivalDistribution> interarrivalDist);

  /// \brief Generate the uniform workload, setting the processing and
  /// communication sizes.
  ///
  /// This member function implements the workload generation logic for the
  /// `UniformWorkload` class. It sets the processing size (`procSize`) and
  /// communication size (`commSize`) to random values within the specified
  /// range of minimum and maximum processing and communication sizes. The
  /// remaining tasks counter in the base class (`Workload::m_RemainingTasks`)
  /// is decremented after generating the workload for a task.
  ///
  /// \param rng The logical process reversible-pseudorandom number generator.
  /// \param procSize A reference to the processing size to be updated based on
  /// the uniform workload generation. \param commSize A reference to the
  /// communication size to be updated based on the uniform workload generation.
  void generateWorkload(tw_rng_stream *rng, double &procSize,
                        double &commSize, unsigned flag) override {
    CHECK_RNG(rng);

    procSize =
        m_MinProcSize + tw_rand_unif(rng) * (m_MaxProcSize - m_MinProcSize);
    commSize =
        m_MinCommSize + tw_rand_unif(rng) * (m_MaxCommSize - m_MinCommSize);

    if(flag == VM_FLAG)
      Workload::m_RemainingVms--;
    else
      Workload::m_RemainingTasks--;
    ispd_debug("[Uniform Workload] Workload (%lf, %lf) generated. RT: %u.",
               procSize, commSize, Workload::m_RemainingTasks);
  }

  /// \brief Reverse the uniform workload generation, needed due to Time Warp's
  /// rollback mechanism.
  ///
  /// This member function reverses the workload generation for the
  /// `UniformWorkload` class to support Time Warp's rollback mechanism. When a
  /// rollback occurs, the remaining tasks counter in the base class
  /// (`Workload::m_RemainingTasks`) is incremented to revert the effects of
  /// generating workload for a task. Additionally, the two previous calls to
  /// `tw_rand_unif` that were used to generate the processing and communication
  /// sizes are reversed using `tw_rand_reverse_unif`.
  ///
  /// \param rng The logical process reversible-pseudorandom number generator.
  void reverseGenerateWorkload(tw_rng_stream *rng, unsigned flag) override {
    CHECK_RNG(rng);

    /// The following two function calls reverse the use of two times
    /// of the `tw_rand_unif` at the `generateWorkload` member-function.
    ///
    ///   1. The first call reverse the pseudorandom number generation for
    ///      the processing size generation.
    ///
    ///   2. The second call reverse the pseudorandom nubmer genration for
    ///      the communication size generation.
    tw_rand_reverse_unif(rng);
    tw_rand_reverse_unif(rng);

    if(flag == VM_FLAG)
      Workload::m_RemainingVms++;
    else
      Workload::m_RemainingTasks++;
    ispd_debug("[Uniform Workload] Reversed. RT: %u.",
               Workload::m_RemainingTasks);
  }
};

/// \brief Null Workload Class
///
/// The NullWorkload class is a concrete implementation of the Workload interface, specifically designed to represent
/// a "null" or "empty" workload. It is used when no actual tasks need to be generated or processed, serving as a placeholder
/// to indicate the absence of workload.
class NullWorkload : public Workload {
public:
    /// \brief Null Workload Constructor
    ///
    /// Initializes a new instance of the NullWorkload class with zero tasks.
    ///
    /// \param owner The user who create the workload.
    explicit NullWorkload(const std::string& owner);

    /// \brief Generate Workload
    ///
    /// This method is overridden from the base Workload class. Since the NullWorkload represents an empty workload,
    /// attempting to generate tasks will result in an error being raised.
    ///
    /// \param rng A pointer to the random number generator stream.
    /// \param procSize A reference to the variable storing the generated processing size.
    /// \param commSize A reference to the variable storing the generated communication size.
    void generateWorkload(tw_rng_stream *rng, double &procSize, double &commSize, unsigned flag) override {
        ispd_error("[Null Workload] A null workload cannot be generated.");
    }

    /// \brief Reverse Generate Workload
    ///
    /// This method is overridden from the base Workload class. Since the NullWorkload represents an empty workload,
    /// attempting to reverse generate tasks will result in an error being raised.
    ///
    /// \param rng A pointer to the random number generator stream.
    void reverseGenerateWorkload(tw_rng_stream *rng, unsigned flag) override {
        ispd_error("[Null Workload] A null workload generation cannot be reversed.");
    }
};

/// \brief Create a new ConstantWorkload object with specified parameters.
///
/// This function is a helper function that creates and returns a new instance
/// of the ConstantWorkload class. It simplifies the process of creating
/// ConstantWorkload objects by encapsulating the object instantiation and
/// returning a pointer to the newly created object.
///
/// \param user The user who created the workload.
/// \param remainingTasks The total number of tasks that need to be generated by
///                       the workload.
/// \param constantProcSize The constant processing size to be set for all
///                         generated tasks.
/// \param constantCommSize The constant communication size to be set for
///                         all generated tasks.
/// \param interarrivalDist Unique pointer to associated interarrival distribution.
///
/// \returns A pointer to the newly created ConstantWorkload object.
///
/// \note This function uses dynamic memory allocation to create the
///       ConstantWorkload object on the heap. The caller is responsible for
///       managing the object's memory and must eventually delete the object
///       when it is no longer needed to avoid memory leaks.
ConstantWorkload *constant(const std::string& user,
                           const unsigned remainingTasks,
                           const double constantProcSize,
                           const double constantCommSize,
                           std::unique_ptr<InterarrivalDistribution> interarrivalDist);

ConstantWorkload *constant(const std::string& user,
                           const unsigned remainingTasks,
                           const unsigned remainingVms,
                           const double constantProcSize,
                           const double constantCommSize,
                           std::unique_ptr<InterarrivalDistribution> interarrivalDist);

/// \brief Create a new UniformWorkload object with specified parameters.
///
/// This function is a helper function that creates and returns a new instance
/// of the UniformWorkload class. It simplifies the process of creating
/// UniformWorkload objects by encapsulating the object instantiation and
/// returning a pointer to the newly created object.
///
/// \param user The user who created the workload.
/// \param remainingTasks The total number of tasks that need to be generated by
///                       the workload.
/// \param minProcSize The minimum processing size to be set for generated
///                    tasks.
/// \param maxProcSize The maximum processing size to be set for generated
///                    tasks.
/// \param minCommSize The minimum communication size to be set for generated
///                    tasks.
/// \param maxCommSize The maximum communication size to be set for generated
///                    tasks.
/// \param interarrivalDist Unique pointer to associated interarrival distribution.
///
/// \returns A pointer to the newly created UniformWorkload object.
///
/// \note This function uses dynamic memory allocation to create the
/// UniformWorkload object on the heap. The caller is responsible for managing
/// the object's memory and must eventually delete the object when it is no
/// longer needed to avoid memory leaks.
UniformWorkload *uniform(const std::string& user,
                         const unsigned remainingTasks,
                         const double minProcSize,
                         const double maxProcSize,
                         const double minCommSize,
                         const double maxCommSize,
                         std::unique_ptr<InterarrivalDistribution> interarrivalDist);


/// \brief Get Null Workload
///
/// The `null()` function returns an instance of the `NullWorkload` class, which represents a placeholder for an empty workload.
/// This function is used to obtain a `NullWorkload` instance when there is no actual workload to be generated.
/// The returned instance has predefined behavior to handle cases where a workload is not applicable.
/// 
/// \param user The user who create the workload.
///
/// \return An instance of the `NullWorkload` class.
NullWorkload *null(const std::string& user);

}; // namespace ispd::workload

#endif // ISPD_WORKLOAD_HPP
