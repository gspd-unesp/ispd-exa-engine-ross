#ifndef ISPD_WORKLOAD_HPP
#define ISPD_WORKLOAD_HPP

#include <ross.h>
#include <memory>
#include <ispd/log/log.hpp>
#include <ispd/model/user.hpp>
#include <ispd/workload/interarrival.hpp>

#define CHECK_RNG(rng)                                                         \
  DEBUG({                                                                      \
    if (!rng)                                                                  \
      ispd_error("The logical process' reversible-pseudorandom number "        \
                 "generator has not been provided.");                          \
  })

namespace ispd::workload {

/// \class Workload
///
/// \brief A base class representing a workload to be generated for a
/// simulation.
///
class Workload {
protected:
  /// \brief Stores the user who created the workload.
  ///
  /// This member variable holds an integer representing the identifier of the
  /// user-defined workload associated with the current instance of the Workload
  /// class.
  ///
  /// The user identifier who created the workload can provide context and
  /// information about the specific type of workload being simulated, making it
  /// easier to interpret and analyze simulation results or performance metrics.
  ispd::model::User::uid_t m_Owner;

  /// \brief The remaining tasks to be generated by this workload.
  ///
  /// The `m_RemainingTasks` member stores the count of tasks that are yet to be
  /// generated by the workload. It is decremented as tasks are generated during
  /// the simulation. This information allows simulation components to keep
  /// track of the workload progress and workload generation termination
  /// conditions.
  unsigned m_RemainingTasks;

  /// \brief Represents the computing offload as a percentage of a workload's
  ///        computing size that will be processed by the GPU.
  ///
  /// The `m_ComputingOffload` variable within the class encapsulates the
  /// concept of computing offload, which signifies the portion of a workload's
  /// computational size that will be executed on a GPU rather than on the CPU.
  /// The value of `m_ComputingOffload` is expressed as a floating-point number
  /// between 0 and 1, where 0 indicates no offloading (all computation on CPU)
  /// and 1 indicates full offloading (all computation on GPU). This parameter
  /// plays a pivotal role in determining the distribution of computing tasks
  /// between different processing units, optimizing performance, energy
  /// efficiency, and resource utilization.
  ///
  /// The choice of a specific value for `m_ComputingOffload` will depend on
  /// factors such as the capabilities of the available hardware, the nature of
  /// the workload, and performance goals. It offers the flexibility to
  /// fine-tune the balance between CPU and GPU processing for optimal execution
  /// efficiency.
  ///
  /// \note It is important to ensure that the value of `m_ComputingOffload`
  /// remains within the range of [0, 1] to ensure an accurate representation of
  /// the workload's processing distribution.
  ///
  /// \note The unit of measurement for computing offload is in gigatransfers
  /// per second (GT/s).
  ///
  double m_ComputingOffload;

  /// \brief Unique pointer to InterarrivalDistribution.
  ///
  /// This member variable holds a `std::unique_ptr` to an
  /// `InterarrivalDistribution` object associated with the current instance of
  /// the Workload class. The `InterarrivalDistribution` is responsible for
  /// generating time intervals between the arrivals of consecutive events
  /// within the workload.
  ///
  /// Using a `std::unique_ptr` ensures proper memory management and ownership
  /// of the dynamically allocated `InterarrivalDistribution` object. This
  /// allows flexible and efficient handling of different interarrival
  /// distribution types and ensures that the object is properly deallocated
  /// when the Workload is no longer in use.
  std::unique_ptr<InterarrivalDistribution> m_InterarrivalDist;

public:
  /// \brief Constructor for the Workload class.
  ///
  /// Creates a new `Workload` object with the specified user, remaining tasks,
  /// and an associated interarrival distribution.
  ///
  /// \param owner The user who created the workload.
  /// \param remainingTasks The total number of tasks that need to be generated
  ///                       by the workload.
  /// \param computingOffload The percentage of the computation size that will
  ///                         be offloaded to the GPU. Expressed as a
  ///                         floating-point number between 0 and 1.
  /// \param interarrivalDist A unique pointer to an InterarrivalDistribution
  ///                        object that represents the distribution of time
  ///                        between consecutive task arrivals.
  [[nodiscard]] explicit Workload(
      const std::string &owner, const unsigned remainingTasks,
      const double computingOffload,
      std::unique_ptr<InterarrivalDistribution> interarrivalDist) noexcept;

  /// \brief Generate the workload, setting the processing and communication
  ///        sizes depending on the generation policy.
  ///
  /// This pure virtual function defines the interface for workload generation
  /// in derived classes. Each derivezd workload class must implement this
  /// function to generate the workload's processing and communication sizes
  /// based on the specific generation policy. The actual logic for generating
  /// workload characteristics can vary between different workload types.
  ///
  /// \param rng The logical process reversible-pseudonumber random generator.
  /// \param procSize A reference to the processing size to be updated based on
  ///                 the generated workload.
  /// \param commSize A reference to the communication size to be updated based
  ///                 on the generated workload.
  virtual void generateWorkload(tw_rng_stream *rng, double &procSize,
                                double &commSize) = 0;

  /// \brief Reverse the workload generation, necessary due to the Time Warp's
  ///        rollback mechanism.
  ///
  /// This pure virtual function defines the interface for reversing the
  /// workload generation in derived classes. Time Warp is a distributed
  /// discrete-event simulation technique that allows for virtual time rollback
  /// to correct causality errors. To support rollback, this function enables
  /// the workload generation to be reversed, so the simulation can roll back
  /// the workload's state if necessary.
  ///
  /// \param rng The logical process reversible-pseudorandom number generator.
  virtual void reverseGenerateWorkload(tw_rng_stream *rng) = 0;

  /// \brief Generates the time until the next event's arrival using the
  /// interarrival distribution.
  ///
  /// This function generates the time until the next event's arrival based on
  /// the specified interarrival distribution. The generated time offset is
  /// stored in the provided 'offset' parameter. The interarrival distribution
  /// is determined by the type of interarrival distribution object associated
  /// with the current instance of the Workload class.
  ///
  /// \param rng A pointer to the logical process reversible-pseudorandom number
  /// generator. \param offset A reference to a variable where the generated
  /// time offset will be stored.
  inline void generateInterarrival(tw_rng_stream *const rng, double &offset) {
    m_InterarrivalDist->generateInterarrival(rng, offset);
  }

  /// \brief Reverses the generation of the last interarrival time, necessary
  /// due to the
  ///        Time Warp's rollback mechanism.
  ///
  /// This function is used to reverse the generation of the last interarrival
  /// time when performing backtracking during the simulation. It relies on the
  /// reverse generation mechanism provided by the associated interarrival
  /// distribution object.
  ///
  /// \param rng A pointer to the logical process reversible-pseudorandom number
  /// generator.
  inline void reverseGenerateInterarrival(tw_rng_stream *const rng) {
    m_InterarrivalDist->reverseGenerateInterarrival(rng);
  }

  /// \brief Get the remaining tasks to be generated by this workload.
  ///
  /// \returns The number of tasks that are yet to be generated by the workload.
  ///
  /// \note This function provides access to the `m_RemainingTasks` member,
  ///       which stores the count of remaining tasks. It is used by simulation
  ///       components to monitor the progress of workload generation and
  ///       determine workload generation termination conditions.
  [[nodiscard]] inline unsigned getRemainingTasks() const noexcept {
    return m_RemainingTasks;
  }

  /// \brief Get the computing offload ratio of the workload.
  ///
  /// Retrieves the computing offload ratio for GPU processing associated with
  /// this workload.
  ///
  /// The computing offload ratio represents the proportion of the computational
  /// size of the tasks from the workload that are offloaded to a GPU for
  /// processing. It is expressed as a floating-point number between 0 and 1,
  /// where 0 indicates no offloading and 1 indicates full offloading.
  ///
  /// \return The computing offload ratio of the workload's computational size.
  ///
  /// \note The computing offload ratio provides insights into the distribution
  ///       of computational tasks between the CPU and GPU, enabling analysis of
  ///       workload optimization strategies.
  [[nodiscard]] inline double getComputingOffload() const noexcept {
    return m_ComputingOffload;
  }

  /// \brief Get the user identifier who create the workload.
  ///
  /// This member function returns the user identifier who created the workload
  /// associated with the current instance of the Workload class.
  ///
  /// \return The user identifier who created the workload.
  [[nodiscard]] inline const ispd::model::User::uid_t
  getOwner() const noexcept {
    return m_Owner;
  }
};

/// \class ConstantWorkload
///
/// \brief A derived class representing a constant workload for simulation
///        tasks, all generated tasks will have the same workload.
///
class ConstantWorkload final : public Workload {
  /// \brief The constant processing size to be set for all generated tasks.
  ///
  /// The `m_ConstantProcSize` member stores the constant processing size that
  /// will be assigned to all tasks generated by this workload. This value
  /// remains constant throughout the simulation for all tasks generated using
  /// this workload.
  double m_ConstantProcSize;

  /// \brief The constant communication size to be set for all generated tasks.
  ///
  /// The `m_ConstantCommSize` member stores the constant communication size
  /// that will be assigned to all tasks generated by this workload. This value
  /// remains constant throughout the simulation for all tasks generated using
  /// this workload.
  double m_ConstantCommSize;

public:
  /// \brief ConstantWorkload class constructor.
  ///
  /// Creates a new `ConstantWorkload` object with the specified parameters.
  ///
  /// \param owner The user who created the workload.
  /// \param remainingTasks The total tasks to be generated by the workload.
  /// \param constantProcSize Constant processing size for all generated tasks.
  /// \param constantCommSize Constant communication size for all generated
  ///                         tasks.
  /// \param computingOffload The percentage of the computatig size that will be
  ///                         offloaded to the GPU. Expressed as a
  ///                         floating-point number between 0 and 1.
  /// \param interarrivalDist Unique pointer to associated interarrival
  ///                         distribution.
  ///
  [[nodiscard]] explicit ConstantWorkload(
      const std::string &owner, const unsigned remainingTasks,
      const double constantProcSize, const double constantCommSize,
      const double computingOffload,
      std::unique_ptr<InterarrivalDistribution> interarrivalDist) noexcept;

  /// \brief Generate the constant workload, setting the processing and
  /// communication sizes.
  ///
  /// This member function implements the workload generation logic for the
  /// `ConstantWorkload` class. It sets the processing size (`procSize`) and
  /// communication size (`commSize`) to the constant values specified during
  /// object construction. The remaining tasks counter in the base class
  /// (`Workload::m_RemainingTasks`) is decremented after generating the
  /// workload for a task.
  ///
  /// \param rng The logical process reversible-pseudorandom number generator.
  /// \param procSize A reference to the processing size to be updated based on
  ///                 the constant workload generation.
  /// \param commSize A reference to the communication size to be updated based
  ///                 on the constant workload generation.
  void generateWorkload(tw_rng_stream *rng, double &procSize,
                        double &commSize) override {
    CHECK_RNG(rng);

    procSize = m_ConstantProcSize;
    commSize = m_ConstantCommSize;

    Workload::m_RemainingTasks--;
  }

  /// \brief Reverse the constant workload generation, needed due to Time Warp's
  /// rollback mechanism.
  ///
  /// This member function reverses the workload generation for the
  /// `ConstantWorkload` class to support Time Warp's rollback mechanism. When a
  /// rollback occurs, the remaining tasks counter in the base class
  /// (`Workload::m_RemainingTasks`) is incremented to revert the effects of
  /// generating workload for a task.
  ///
  /// \param rng The logical process reversible-pseudorandom number generator.
  void reverseGenerateWorkload(tw_rng_stream *rng) override {
    CHECK_RNG(rng);

    Workload::m_RemainingTasks++;
  }
};

/// \class UniformWorkload
///
/// \brief A derived class representing a uniform workload for simulation tasks.
///
class UniformWorkload final : public Workload {
  /// \brief The minimum processing size for generated tasks.
  double m_MinProcSize;

  /// \brief The maximum processing size for generated tasks.
  double m_MaxProcSize;

  /// \brief The minimum communication size for generated tasks.
  double m_MinCommSize;

  /// \brief The maximum communication size for generated tasks.
  double m_MaxCommSize;

public:
  /// \brief UniformWorkload class constructor.
  ///
  /// Creates a new `UniformWorkload` object with the specified parameters.
  ///
  /// \param owner The user who created the workload.
  /// \param remainingTasks Total tasks to be generated by the workload.
  /// \param minProcSize Minimum processing size for generated tasks.
  /// \param maxProcSize Maximum processing size for generated tasks.
  /// \param minCommSize Minimum communication size for generated tasks.
  /// \param maxCommSize Maximum communication size for generated tasks.
  /// \param computingOffload The percentage of the computatig size that will be
  ///                         offloaded to the GPU. Expressed as a
  ///                         floating-point number between 0 and 1.
  /// \param interarrivalDist Unique pointer to associated interarrival
  ///                         distribution.
  ///
  [[nodiscard]] explicit UniformWorkload(
      const std::string &owner, const unsigned remainingTasks,
      const double minProcSize, const double maxProcSize,
      const double minCommSize, const double maxCommSize,
      const double computingOffload,
      std::unique_ptr<InterarrivalDistribution> interarrivalDist) noexcept;

  /// \brief Generate the uniform workload, setting the processing and
  /// communication sizes.
  ///
  /// This member function implements the workload generation logic for the
  /// `UniformWorkload` class. It sets the processing size (`procSize`) and
  /// communication size (`commSize`) to random values within the specified
  /// range of minimum and maximum processing and communication sizes. The
  /// remaining tasks counter in the base class (`Workload::m_RemainingTasks`)
  /// is decremented after generating the workload for a task.
  ///
  /// \param rng The logical process reversible-pseudorandom number generator.
  /// \param procSize A reference to the processing size to be updated based on
  /// the uniform workload generation. \param commSize A reference to the
  /// communication size to be updated based on the uniform workload generation.
  void generateWorkload(tw_rng_stream *rng, double &procSize,
                        double &commSize) override {
    CHECK_RNG(rng);

    procSize =
        m_MinProcSize + tw_rand_unif(rng) * (m_MaxProcSize - m_MinProcSize);
    commSize =
        m_MinCommSize + tw_rand_unif(rng) * (m_MaxCommSize - m_MinCommSize);

    Workload::m_RemainingTasks--;

    ispd_debug("[Uniform Workload] Workload (%lf, %lf) generated. RT: %u.",
               procSize, commSize, Workload::m_RemainingTasks);
  }

  /// \brief Reverse the uniform workload generation, needed due to Time Warp's
  /// rollback mechanism.
  ///
  /// This member function reverses the workload generation for the
  /// `UniformWorkload` class to support Time Warp's rollback mechanism. When a
  /// rollback occurs, the remaining tasks counter in the base class
  /// (`Workload::m_RemainingTasks`) is incremented to revert the effects of
  /// generating workload for a task. Additionally, the two previous calls to
  /// `tw_rand_unif` that were used to generate the processing and communication
  /// sizes are reversed using `tw_rand_reverse_unif`.
  ///
  /// \param rng The logical process reversible-pseudorandom number generator.
  void reverseGenerateWorkload(tw_rng_stream *rng) override {
    CHECK_RNG(rng);

    /// The following two function calls reverse the use of two times
    /// of the `tw_rand_unif` at the `generateWorkload` member-function.
    ///
    ///   1. The first call reverse the pseudorandom number generation for
    ///      the processing size generation.
    ///
    ///   2. The second call reverse the pseudorandom nubmer genration for
    ///      the communication size generation.
    tw_rand_reverse_unif(rng);
    tw_rand_reverse_unif(rng);

    Workload::m_RemainingTasks++;

    ispd_debug("[Uniform Workload] Reversed. RT: %u.",
               Workload::m_RemainingTasks);
  }
};

/// \brief Set the type of a two-stage uniform distribution.
///
/// This four-component tuple represents a two-stage uniform distribution
/// containing the following parameters in the order they are listed.
///
///  1. Minimum Value: Represents the minimum generated value possible.
///
///  2. Medium Value: Represents the maximum generated value possible
///                   for the left stage distribution, and represents the
///                   minimum generated value possible for the right stage
///                   distribution.
///
///  3. Maximum Value: Represents the maximum generated value possible.
///
///  4. Stage Selection Probability: Represents a value in the interval
///                                  [0, 1], which indicates the probability
///                                  to select the left stage distribution
///                                  over the right one.
///
using TwoStageDistribution = std::tuple<double, double, double, double>;

/// \enum TwoStageDistSelector
///
/// \brief Used for name-to-value conversion for adding semantics to
///        select the %TwoStageDistribution parameters.
///
///! We don't want it to be a enum class, since we would like to use
///! the name-to-integer value directly.
enum TwoStageDistSelector { MINIMUM = 0, MEDIUM, MAXIMUM, PROBABILITY };

/// \class TwoStageUniformWorkload
///
/// \brief A derived class representing a two-stage uniform workload.
class TwoStageUniformWorkload final : public Workload {
  /// \brief The two-stage uniform distribution for generate processing sizes.
  TwoStageDistribution m_ProcDist;

  /// \brief The two-stage uniform distribution for generate communication
  /// sizes.
  TwoStageDistribution m_CommDist;

public:
  /// \brief TwoStageUniformWorkload class constructor.
  ///
  /// Creates a new `TwoStageUniformWorkload` object with the specified
  /// parameters.
  ///
  /// \param owner The user who created the workload.
  /// \param remainingTasks Total tasks to be generated by the workload.
  /// \param computingOffload The percentage of the computatig size that will be
  ///                         offloaded to the GPU. Expressed as a
  ///                         floating-point number between 0 and 1.
  /// \param procDist The two-stage uniform for generate processing sizes.
  /// \param commDist The two-stage uniform for generate communication sizes.
  /// \param interarrivalDist Unique pointer to associated interarrival
  ///                         distribution.
  ///
  [[nodiscard]] explicit TwoStageUniformWorkload(
      const std::string &owner, const unsigned remainingTasks,
      const double computingOffload, const TwoStageDistribution procDist,
      const TwoStageDistribution commDist,
      std::unique_ptr<InterarrivalDistribution> interarrivalDist) noexcept;

  /// \brief Generate thw two-stage uniform workload, setting the processing
  ///        and communication sizes.
  ///
  /// This member functions implements the workload generation logic for the
  /// `TwoStageUniformWorkload` class. It sets the processing size (`procSize`)
  /// and communication size (`commSize`) to random values within the specified
  /// range of minimum and maximum processing and communication sizes of two
  /// different uniform distributions that is selected based on a selection
  /// probability.
  ///
  /// \param rng The logical process reversible-pseudorandom number generator.
  /// \param procSize A reference to the processing sdize to be updated based
  ///                 on the two-stage uniform workload generation.
  /// \param commSize A reference to the communication size to be updated based
  ///                 on the two-stage uniform workload generation.
  void generateWorkload(tw_rng_stream *rng, double &procSize,
                        double &commSize) override {
    CHECK_RNG(rng);

    // Generate two numbers in the interval [0, 1], being each one
    // used to select the processing and communication distribution
    // stage, respectively.
    const double procStageSelection = tw_rand_unif(rng);
    const double commStageSelection = tw_rand_unif(rng);

    double minProcSize, maxProcSize;
    double minCommSize, maxCommSize;

    // Select the two stage uniform distribution parameters for the
    // processing size based on thee specified probability for the stage
    // selection.
    if (std::get<TwoStageDistSelector::PROBABILITY>(m_ProcDist) <=
        procStageSelection) {
      minProcSize = std::get<TwoStageDistSelector::MINIMUM>(m_ProcDist);
      maxProcSize = std::get<TwoStageDistSelector::MEDIUM>(m_ProcDist);
    } else {
      minProcSize = std::get<TwoStageDistSelector::MEDIUM>(m_ProcDist);
      maxProcSize = std::get<TwoStageDistSelector::MAXIMUM>(m_ProcDist);
    }

    // Select the two stage uniform distribution parameters for the
    // communication size based on thee specified probability for the stage
    // selection.
    if (std::get<TwoStageDistSelector::PROBABILITY>(m_CommDist) <=
        commStageSelection) {
      minCommSize = std::get<TwoStageDistSelector::MINIMUM>(m_CommDist);
      maxCommSize = std::get<TwoStageDistSelector::MEDIUM>(m_CommDist);
    } else {
      minCommSize = std::get<TwoStageDistSelector::MEDIUM>(m_CommDist);
      maxCommSize = std::get<TwoStageDistSelector::MAXIMUM>(m_CommDist);
    }

    procSize = minProcSize + tw_rand_unif(rng) * (maxProcSize - minProcSize);
    commSize = minCommSize + tw_rand_unif(rng) * (maxCommSize - minCommSize);

    Workload::m_RemainingTasks--;

    ispd_debug(
        "[TwoStageUniform Workload] Workload (%lf, %lf) generated. RT: %u.",
        procSize, commSize, Workload::m_RemainingTasks);
  }

  /// \brief Reverse the two-stage uniform workload generation, needed due to
  ///        Time Warp's rollback mechanism.
  ///
  /// \note This member function reverses the workload generation for the
  ///       `TwoStageUniformWorkload` class to support Time Warp's rollback
  ///       mechanism. When a rollback occurs, the remaining tasks counter in
  ///       the base class (`Workload::m_RemainingTasks`) is incremented to
  ///       revert the effects of generating workload for a task. Additionally,
  ///       the four previous calls to `tw_rand_unif` that were used to generate
  ///       the processing and communication sizes are reversed using
  ///       `tw_rand_reverse_unif`.
  void reverseGenerateWorkload(tw_rng_stream *rng) override {
    CHECK_RNG(rng);

    // The following four function calls reverse the use of four times
    // of the `tw_rand_unif` at the `generateWorkload` member function.
    //
    //   1. The first call reverse the pseudorandom number generation for
    //      obtain a random number for select which processing stage
    //      distribution will be selected.
    //
    //   2. The second call reverse the pseudorandom number generation for
    //      obtain a random number for select which communication stage
    //      distribution will be selected.
    //
    //   3. The third call reverse the pseudorandom number generation for
    //      the processing size generation.
    //
    //   4. The fourth call reverse the pseudorandom nubmer genration for
    //      the communication size generation.
    //
    tw_rand_reverse_unif(rng);
    tw_rand_reverse_unif(rng);
    tw_rand_reverse_unif(rng);
    tw_rand_reverse_unif(rng);

    Workload::m_RemainingTasks++;

    ispd_debug("[TwoStageUniform Workload] Reversed. RT: %u.",
               Workload::m_RemainingTasks);
  }
};

/// \brief Null Workload Class
///
/// The NullWorkload class is a concrete implementation of the Workload
/// interface, specifically designed to represent a "null" or "empty" workload.
/// It is used when no actual tasks need to be generated or processed, serving
/// as a placeholder to indicate the absence of workload.
class NullWorkload final : public Workload {
public:
  /// \brief Null Workload Constructor
  ///
  /// Initializes a new instance of the NullWorkload class with zero tasks.
  ///
  /// \param owner The user who create the workload.
  [[nodiscard]] explicit NullWorkload(const std::string &owner) noexcept;

  /// \brief Generate Workload
  ///
  /// This method is overridden from the base Workload class. Since the
  /// NullWorkload represents an empty workload, attempting to generate tasks
  /// will result in an error being raised.
  ///
  /// \param rng A pointer to the random number generator stream.
  /// \param procSize A reference to the variable storing the generated
  /// processing size. \param commSize A reference to the variable storing the
  /// generated communication size.
  void generateWorkload(tw_rng_stream *rng, double &procSize,
                        double &commSize) noexcept override {
    ispd_error("[Null Workload] A null workload cannot be generated.");
  }

  /// \brief Reverse Generate Workload
  ///
  /// This method is overridden from the base Workload class. Since the
  /// NullWorkload represents an empty workload, attempting to reverse generate
  /// tasks will result in an error being raised.
  ///
  /// \param rng A pointer to the random number generator stream.
  void reverseGenerateWorkload(tw_rng_stream *rng) noexcept override {
    ispd_error(
        "[Null Workload] A null workload generation cannot be reversed.");
  }
};

/// \brief Create a new ConstantWorkload object with specified parameters.
///
/// This function is a helper function that creates and returns a new instance
/// of the ConstantWorkload class. It simplifies the process of creating
/// ConstantWorkload objects by encapsulating the object instantiation and
/// returning a pointer to the newly created object.
///
/// \param user The user who created the workload.
/// \param remainingTasks The total number of tasks that need to be generated by
///                       the workload.
/// \param constantProcSize The constant processing size to be set for all
///                         generated tasks.
/// \param constantCommSize The constant communication size to be set for
///                         all generated tasks.
/// \param computingOffload The percentage of the computation size that will
///                         be offloaded to the GPU. Expressed as a
///                         floating-point number between 0 and 1.
/// \param interarrivalDist Unique pointer to associated interarrival
/// distribution.
///
/// \returns A pointer to the newly created ConstantWorkload object.
///
/// \note This function uses dynamic memory allocation to create the
///       ConstantWorkload object on the heap. The caller is responsible for
///       managing the object's memory and must eventually delete the object
///       when it is no longer needed to avoid memory leaks.
ConstantWorkload *
constant(const std::string &user, const unsigned remainingTasks,
         const double constantProcSize, const double constantCommSize,
         const double computingOffload,
         std::unique_ptr<InterarrivalDistribution> interarrivalDist);

/// \brief Create a new UniformWorkload object with specified parameters.
///
/// This function is a helper function that creates and returns a new instance
/// of the UniformWorkload class. It simplifies the process of creating
/// UniformWorkload objects by encapsulating the object instantiation and
/// returning a pointer to the newly created object.
///
/// \param user The user who created the workload.
/// \param remainingTasks The total number of tasks that need to be generated by
///                       the workload.
/// \param minProcSize The minimum processing size to be set for generated
///                    tasks.
/// \param maxProcSize The maximum processing size to be set for generated
///                    tasks.
/// \param minCommSize The minimum communication size to be set for generated
///                    tasks.
/// \param maxCommSize The maximum communication size to be set for generated
///                    tasks.
/// \param computingOffload The percentage of the computation size that will
///                         be offloaded to the GPU. Expressed as a
///                         floating-point number between 0 and 1.
/// \param interarrivalDist Unique pointer to associated interarrival
/// distribution.
///
/// \returns A pointer to the newly created UniformWorkload object.
///
/// \note This function uses dynamic memory allocation to create the
/// UniformWorkload object on the heap. The caller is responsible for managing
/// the object's memory and must eventually delete the object when it is no
/// longer needed to avoid memory leaks.
UniformWorkload *
uniform(const std::string &user, const unsigned remainingTasks,
        const double minProcSize, const double maxProcSize,
        const double minCommSize, const double maxCommSize,
        const double computingOffload,
        std::unique_ptr<InterarrivalDistribution> interarrivalDist);

/// \brief Create a new TwoStageUniformWorkload object with specified
/// parameters.
///
/// This function is a helper function that creates and returns a new instance
/// of the TwoStageUniformWorkload class. It simplifies the process of creating
/// TwoStageUniformWorkload objects by encapsulating the object instantiation
/// and returning a pointer to the newly created object.
///
/// \param user The user who created the workload.
/// \param remainingTasks The total number of tasks that need to be generated by
///                       the workload.
/// \param computingOffload The percentage of the computation size that will
///                         be offloaded to the GPU. Expressed as a
///                         floating-point number between 0 and 1.
/// \param procDist The two-stage uniform distribution for processing sizes.
/// \param commDist The two-stage uniform distribution for communication sizes.
/// \param interarrivalDist Unique pointer to associated interarrival
///                         distribution.
///
/// \returns A pointer to the newly created UniformWorkload object.
///
/// \note This function uses dynamic memory allocation to create the
/// UniformWorkload object on the heap. The caller is responsible for managing
/// the object's memory and must eventually delete the object when it is no
/// longer needed to avoid memory leaks.
///
TwoStageUniformWorkload *
twoStage(const std::string &user, const unsigned remainingTasks,
         const double computingOffload, const TwoStageDistribution procDist,
         const TwoStageDistribution commDist,
         std::unique_ptr<InterarrivalDistribution> interarrivalDist);

/// \brief Get Null Workload
///
/// The `null()` function returns an instance of the `NullWorkload` class, which
/// represents a placeholder for an empty workload. This function is used to
/// obtain a `NullWorkload` instance when there is no actual workload to be
/// generated. The returned instance has predefined behavior to handle cases
/// where a workload is not applicable.
///
/// \param user The user who create the workload.
///
/// \return An instance of the `NullWorkload` class.
NullWorkload *null(const std::string &user);

}; // namespace ispd::workload

#endif // ISPD_WORKLOAD_HPP
